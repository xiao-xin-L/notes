## js的变量声明方式

1. `var`的变量提升
   * 无论在哪个作用域中, var指令都会被提前到该作用域代码的最前
   
2. 函数的变量提升
   * 无论在哪个作用域中，函数声明指令也都会被提前到该作用域代码的最前，函数声明指令会被提前到`var`指令之前
   
3. `let`,`const`指令

   * var指令创造的变量只有函数作用域，在控制流程内不会产生作用域，外面也可以访问到控制流程内部的变量
   * 使用let指令创造的变量，存在块级作用域, 控制流程内部用let指令定义的变量，在控制流程外部无法获取
   * 已经使用var声明的变量再次声明，var指令会被忽略，let指令会报错
   * 已经使用let声明的变量再次声明，var和let都会操作
   * let没有变量提升，存在临时死区
   * const与let类似，区别就是const是定义常量的，初始化就要赋值，定义好后不能修改

4. js的垃圾回收
   * 标记清除 (**mark-and-sweep**) (常用)
     * 当变量进入环境(作用域)，则将变量标记为进入环境，当变量离开环境的时候，将其标记为离开环境
     * 垃圾收集器在运行时会给存储在内存中所有变量标记，然后去掉环境变量与被环境变量引用的变量，剩下的就是环境无法访问的变量，这些变量以及其占用的内容空间将被清理回收
   * 引用计数 (**reference counting**)
     * 跟踪每一个值得引用次数。当声明一个引用并将一个引用类型赋值给这个变量得时候，这个值得引用计数加1，如果又把这个引用给了第三个变量，那么引用计数又加1，变成2。如果有变量得引用被指向了别的值，那么引用计数减1，直到等于0。意味着这个值已经不会被变量引用，垃圾收集器下次运行得时候就会清理引用为0得值所占据得内存
     * 如果一个值得引用出现闭环得话，这个值得引用不会变为0，循环引用使得值得内存永远得不到回收。意味着永远占用内存
     * 因此，对于不需要的值，或者使用完的值，请手动将变量的指向清除

5. 函数的闭包原理

   * 函数可以通过作用域链互相关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性被称为闭包

   * 保证参数被引用，避免垃圾回收（延长作用域）
   * 只要参数一直被引用，就永远不会垃圾回收

6. 关于`var`和`let`的经典案例

   ```js
   var oDiv = document.querySelectAll("div");
   
   for(var i = 0; i < 5; i++){
       oDiv.onclick = function(){
           console.log(i);
       }
   }
   // 无论点击哪个按钮都是 5
   
   var oDiv = document.querySelectAll("div");
   
   for(let i = 0; i < 5; i++){
       oDiv.onclick = function(){
           console.log(i);
       }
   }
   // 点击的按钮从1-5
   
   // var 和 let 的区别就是块级作用域
   ```

   