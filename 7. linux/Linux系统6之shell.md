# Linux系统6之shell

shell是系统跟计算机硬件交互时使用的中间介质，它只是系统的一个工具。实际上，在shell和计算机硬件之间还有一层东西——系统内核

用户直接面对的不是计算机硬件而是shell，用户把指令告诉shell，然后shell再传输给系统内核，接着内核再去支配计算机硬件去执行各种操作。

## 1 用户的历史指令

![image-20200308213915926](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200308213915926.png)

我们执行过的命令Linux都会记录，预设可以记录1000条历史命令。这些命令保存在用户的家目录的.bash_history文件中。但需要注意的是，只有当用户正常退出当前shell时，在当前shell中运行的命令才会保存至.bash_history文件中。

![image-20200308214117350](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200308214117350.png)

## 2 命令别名 alias

alias，它是bash所特有的功能之一。我们可以通过alias把一个常用的并且很长的指令另取名为一个简单易记的指令。如果不想用了，还可以使用unalias命令解除别名功能。直接执行alias命令，会看到目前系统预设的别名，如下所示：

![image-20200308215344654](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200308215344654.png)

我们可以给 ls -lh指令重新命名为kuxuan

![image-20200308215952306](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200308215952306.png)

![image-20200308220042253](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200308220042253.png)

使用unalias可以解除命令的别名

![image-20200308220131507](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200308220131507.png)



## 3 通配符和?符

在shell下 我们可以使用*来匹配零个或多个字符，用?匹配一个字符

![image-20200308220715100](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200308220715100.png)



## 4 变量

比如环境变量PATH，它是shell预设的一个变量。通常，shell预设的变量都是大写的。变量就是使用一个较简单的字符串来替代某些具有特殊意义的设定以及数据。就拿PATH来讲，这个PATH就代替了所有常用命令的绝对路径的设定。有了PATH这个变量，我们运行某个命令时，就不再需要输入全局路径，直接输入命令名即可。你可以使用echo命令显示变量的值

![image-20200308221055374](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200308221055374.png)

注意 取用变量的时候 前面要加一个$符号

### 4.1 命令env

使用env命令，可列出系统预设的全部系统变量

![image-20200308224353041](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200308224353041.png)



登录不同的用户，这些环境变量的值也不同。当前显示的是root账户的环境变量。下面简单介绍一下常见的环境变量。
 HOSTNAME：表示主机的名称。
 SHELL：表示当前用户的shell类型。
 HISTSIZE：表示历史记录数。
 MAIL：表示当前用户的邮件存放目录。
 PATH：该变量决定了shell将到哪些目录中寻找命令或程序。
 PWD：表示当前目录。
 LANG：这是与语言相关的环境变量，多语言环境可以修改此环境变量。
 HOME：表示当前用户的家目录。
 LOGNAME：表示当前用户的登录名。
env命令显示的变量只是环境变量，系统预设的变量其实还有很多，你可以使用set命令把系统预设的全部变量都显示出来

### 4.2 命令set

set命令和env命令类似，也可以输出环境变量

set命令不仅可以显示系统预设的变量，也可以显示用户自定义的变量。比如，我们自定义一个变量

![image-20200308230407666](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200308230407666.png)

 设定变量的格式为a=b，其中a为变量名，b为变量的内容，等号两边不能有空格。
 变量名只能由字母、数字以及下划线组成，而且不能以数字开头。
 当变量内容带有特殊字符（如空格）时，需要加上单引号。

如果变量内容中需要用到其他命令，运行结果则可以使用反引号

![image-20200308232138403](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200308232138403.png)

虽然你可以自定义变量，但是该变量只能在当前shell中生效, 也就是说, 你把这个命令窗口关闭, 再打开, 就没效了

![image-20200308230939336](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200308230939336.png)

1. 如果想让一个变量永远生效, 那么只需要仿照我们配置环境变量一般, 在/etc/profile 加上一个

export wanzhang=chaojidashuaibi  就行

2. 仅允许当前用户使用该变量。具体的操作方法是：在用户主目录下的.bashrc文件的最后一行加入export wanzhang=chaojidashuaibi，然后运行source .bashrc就可以生效了。这时再登录test账户，wanzhang变量则不会生效了。这里source命令的作用是将目前设定的配置刷新，即不用注销再登录也能生效。

## 5 系统的环境变量和个人环境变量

上面讲了很多系统变量，那么在Linux系统中，这些变量存在哪里呢？为什么用户一登录shell就自动有了这些变量呢？我们先来看看下面几个文件。

- /etc/profile：这个文件预设了几个重要的变量，例如PATH、USER、LOGNAME、MAIL、INPUTRC、HOSTNAME、HISTSIZE、umask等。

- /etc/bashrc：这个文件主要预设umask以及PS1。这个PS1就是我们在输入命令时前面的那串字符。

除了以上两个系统级别的配置文件外，每个用户的主目录下还有以下几个隐藏文件。

 .bash_profile：该文件定义了用户的个人化路径与环境变量的文件名称。每个用户都可使用该文件输入专属于自己的shell信息，当用户登录时，该文件仅仅执行一次。
 .bashrc：该文件包含专属于自己的shell的bash信息，当登录或每次打开新的shell时，该文件会被读取。例如，你可以将用户自定义的别名或者自定义变量写到这个文件中。
 .bash_history：该文件用于记录命令历史。
 .bash_logout：当退出shell时，会执行该文件。你可以将一些清理的工作放到这个文件中。



## 6 Linux shell 中的特殊符号

*代表零个或多个任意字符,?只代表一个任意的字符 . 这俩咱们之前都学过, 这里就一笔带过了.

下面我们来多学习一些新的符号

1. 注释符号#   : 这个符号在Linux中表示注释说明，即#后面的内容都会被忽略
2. 脱义字符\    :这个字符会将后面的特殊符号（如*）还原为普通字符



### 6.1 管道符 |

它的作用是将前面命令的输出作为后面命令的输入。这里提到的后面的命令，**并不是所有的命令都可以的**，一般针对文档操作的命令比较常用。例如cat、less、head、tail、grep、cut、sort、wc、uniq、tee、tr、split、sed、awk等

### 6.2 命令cut

cut命令用来截取某一个字段，其格式为cut -d '分隔字符' [-cf] n，这里的n是数字。该命令有如下几个可用选项。
 -d：后面跟分隔字符，分隔字符要用单引号括起来。
 -c：后面接的是第几个字符。
 -f：后面接的是第几个区块。

![image-20200309211631527](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200309211631527.png)

我们来分析上面的这条指令, cat /etc/passwd 就是把该文件的内容展示出来, 后面管道符就是把本应展示出来的字符作为整个cut指令的输入信息, 然后cut指令用" : "作为分隔符, 把每一行分割成N段, 取出每一行的第一段, 在把这个取出后的信息作为输入, 输入到head指令中, head指令把这个输入的信息只输出前5行

### 6.3 sort

sort命令用做排序，其格式为sort [-t 分隔符] [-kn1,n2] [-nru]，这里n1和n2指的是数字，其他选项的含义如下

 -t：后面跟分隔字符，作用跟cut的-d选项一样。
 -n：表示使用纯数字排序。
 -r：表示反向排序。
 -u：表示去重复。
 -kn1,n2：表示由n1区间排序到n2区间，可以只写-kn1，即对n1字段排序。

如果sort不加任何选项，则从首字符向后依次按ASCII码值进行比较，最后将它们按升序输出

![image-20200309213055222](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200309213055222.png)

### 6.4 命令wc

wc命令用于统计文档的行数、字符数或词数。该命令的常用选项有-l（统计行数）、-m（统计字符数）和-w（统计词数）

![image-20200309215218212](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200309215218212.png)



### 6.5 命令uniq

uniq命令用来删除重复的行

![image-20200309220136089](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200309220136089.png)



![image-20200309220411654](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200309220411654.png)

使用uniq前，必须先给文件排序，否则不管用

![image-20200309220436221](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200309220436221.png)

### 6.6 命令split

split命令用于切割文档，常用的选项为-b和-l。

 -b：表示依据大小来分割文档，单位为byte

 -l：表示依据行数来分割文档

![image-20200309221405184](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200309221405184.png)

如果split不指定目标文件名，则会以xaa、xab...这样的文件名来存取切割后的文件。当然，我们也可以指定目标文件名

![image-20200309221550745](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200309221550745.png)

### 6.7 其他特殊字符

通常，我们都是在一行中输入一个命令，然后回车就运行了。如果想在一行中运行两个或两个以上的命令，需要在命令之间加符号;

![image-20200309223701192](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200309223701192.png)





符号~表示用户的家目录，root用户的家目录是/root ，普通用户则是/home/username

如果想把一条命令放到后台执行，则需要加上符号&，它通常用于命令运行时间较长的情况

## 7 Linux系统的shell脚本

shell脚本并不能作为正式的编程语言，因为它是在Linux的shell中运行的，所以称为shell脚本。事实上，shell脚本就是一些命令的集合 

比如，我想实现这样的操作：
(1) 进入/tmp/目录；
(2) 列出当前目录中所有的文件名；
(3) 把所有当前的文件复制到/root/目录下；
(4) 删除当前目录下所有的文件。

完成以上简单的4步需要在shell窗口中输入4次命令，按4次回车，这不算太难。但如果是输入复杂的命令，一次一次敲键盘会很麻烦。我们不妨把所有的操作都记录到一个文档中，然后去调用文档中的命令，这样一步操作就可以完成。其实这个文档就是shell脚本，只是这个shell脚本有它特殊的格式。

建议凡是自定义的脚本都放到/usr/local/sbin/目录下。这样做的目的是：一来可以更好地管理文档；二来以后接管你工作的管理员都知道自定义脚本放在哪里，方便维护。

### 7.1 第一个shell 脚本文件

![image-20200309233837235](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200309233837235.png)

我们用touch指令 创造一个后缀名为.sh的shell脚本文件

![image-20200310000827880](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310000827880.png)

然后写入以上内容

脚本文件first.sh的第1行要以#! /bin/bash开头，表示该文件使用的是bash语法。如果不设置该行，你的shell脚本也可以
执行，但是不符合规范。#表示注释，后面跟一些该脚本的相关注释内容，以及作者、创建日期或者版本等。当然，这些注释并非必需的， 

![image-20200310000702950](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310000702950.png)

使用该方法运行shell脚本的前提是脚本本身有执行权限，所以需要给脚本加一个x权限。另外，使用sh命令执行一个shell脚本时，可以加-x选项来查看这个脚本的执行过程，这样有利于我们调试这个脚本

![image-20200310000942505](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310000942505.png)

### 7.2 命令 date

date命令在shell脚本中最常用的几个用法如下。

 date +%Y：表示以四位数字格式打印年份。
 date +%y：表示以两位数字格式打印年份。
 date +%m：表示月份。
 date +%d：表示日期。
 date +%H：表示小时。
 date +%M：表示分钟。
 date +%S：表示秒。
 date +%w：表示星期。结果显示0则表示周日。

![image-20200310001128200](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310001128200.png)

### 7.3 shell中的变量

在shell脚本中使用变量会使我们的脚本更加专业，更像是一门语言。如果你写了一个长达1000行的shell脚本，并且脚本中多次出现某一个命令或者路径，而你觉得路径不对想修改一下，就得一个一个修改，或者使用批量替换的命令修改。这样做很麻烦，并且脚本也显得臃肿了很多。变量就是用来解决这个问题的。定义变量的格式为：“变量名=变量的值”。在脚本中引用变量时需要加上符号$，这跟前面介绍的在shell中自定义变量是一致的

![image-20200310140648500](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310140648500.png)

![image-20200310140711624](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310140711624.png)

本例中使用到了反引号，它的作用是将引号中的字符串当成shell命令执行，返回命令的执行结果

### 7.4 shell中的数学运算

数学计算要用[ ]括起来，并且前面要加符号$

![image-20200310141339155](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310141339155.png)

![image-20200310141352346](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310141352346.png)

如果数字运算不加上[ ], 那么就会把+号当做是字符串, 串联起前后变量的值

加上了[]之后, 就如同是js里面的 ${}, 内部的变量的运算结果, 作为整个的输出

### 7.5 和用户交互

read命令用于和用户交互，它把用户输入的字符串作为变量值

![image-20200310145422953](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310145422953.png)

![image-20200310143521443](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310143521443.png)

read指令最后的那个参数就是变量, 相当于我们先定义的变量, 等到用户输入了信息, 这个变量就有了值

### 7.6 shell的控制流程

```bash
if 判断语句1; then
	command
elif 判断语句2; then
	command
else
	command
fi
```

上面这个就是经典的if判断的控制流程

这个有几点与传统的编程语言不甚相同的地方

1. if的判断条件后面有一个分号, 然后再得加一个then
2. else if的写法简写为 elif
3. 判断语句结束后, 需要写一个Finnish的简写  fi

![image-20200310160231601](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310160231601.png)

![image-20200310160952178](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310160952178.png)

如果是数值判断的话, 要使用-lt （小于）、-gt（大于）、-le（小于或等于）、-ge（大于或等于）、-eq（等于）、-ne（不等于）

逻辑判断符是通用的,  与&&. 或||, 非!

在shell脚本中，除了用if来判断逻辑外，还有一种常用的方式——case

```bash
case 变量 in
    value1)
    	command
    ;;
    value2)
    	command
    ;;
    value3)
    	command
    ;;
    *)
    	command
    ;;
esac
```

![image-20200310163259370](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310163259370.png)

![image-20200310163327640](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310163327640.png)

上面的结构中，不限制value的个数，*代表其他值

shell脚本可以算是一种简易的编程语言了，脚本中的循环也是不能缺少的。常用到的循环有for循环和while循环

for循环结构是阿铭在日常运维工作中使用最频繁的循环结构

```bash
for 变量名 in 循环的条件; do
	command
done
```

![image-20200310165134736](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310165134736.png)

![image-20200310165154623](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310165154623.png)

同样, 我们还可以把用户的输入当做是循环的变量

![image-20200310201030785](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310201030785.png)

![image-20200310201128519](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310201128519.png)



while循环的格式也很简单, 可以用来监控一些服务

```bash
while 条件; do
	command
done
```

![image-20200310201850811](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310201850811.png)

![image-20200310201905754](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310201905754.png)

### 7.7 shell中与文档相关的判断

shell脚本中if还经常用于判断文档的属性，比如判断是普通文件还是目录，判断文件是否有读、写、执行权限等。if常用的选项有以下几个。
 -e：判断文件或目录是否存在。
 -d：判断是不是目录以及是否存在。
 -f：判断是不是普通文件以及是否存在。
 -r：判断是否有读权限。
 -w：判断是否有写权限。
 -x：判断是否可执行。

使用if判断时的具体格式如下：

```bash
if [ -e filename ] ; then
	command
fi
```

### 7.8 shell 脚本中的函数

shell脚本中的函数就是先把一段代码整理到一个小单元中，并给这个小单元命名，当用到这段代码时直接调用这个小单元的名字即可。有时候脚本中的某段代码总是重复使用，如果写成函数，每次用到时直接用函数名代替即可，这样不仅节省时间还节省空间。

![image-20200310205302104](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310205302104.png)

![image-20200310205312650](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310205312650.png)

同样, 咱们也可以在函数调用的时候 传入一些参数

![image-20200310205628901](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310205628901.png)

我们可以在调用函数的时候, 跟上一个空格, 再加上参数, 然后我们就可以在函数里面调用这个变量, 调用的函数内部, 可以用$1~n, 来表示传到shell里面的多个参数

![image-20200310210027281](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310210027281.png)

### 7.9 shell脚本中的中断与继续

在shell脚本循环的过程中，我们难免会遇到一些特殊需求，比如当循环到某个地方时需要做一些事情，这时候很有可能需要退出循环，或者跳过本次循环

**break语句**

break用在循环中，不管是for或者while都可以。在脚本中使用它，表示退出该层循环。之所以说层，是因为有时我们会用到嵌套循环，大循环里面还有小循环，而break仅仅是退出那一层循环，它的上层循环不受影响。

![image-20200310211508579](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310211508579.png)

![image-20200310211458696](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310211458696.png)

continue也是使用在循环中的，但和break不同的是，当在shell脚本中遇到continue时，结束的不是整个循环，而是本次循环

![image-20200310214153171](Linux%E7%B3%BB%E7%BB%9F6%E4%B9%8Bshell.assets/image-20200310214153171.png)

其实，还有一个和break、continue类似的用法，那就是exit，它的作用范围更大，直接退出整个shell脚本

